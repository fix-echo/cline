# 集成与扩展

<cite>
**本文档中引用的文件**  
- [mcp.proto](file://proto/cline/mcp.proto)
- [McpHub.ts](file://src/services/mcp/McpHub.ts)
- [addRemoteMcpServer.ts](file://src/core/controller/mcp/addRemoteMcpServer.ts)
- [api-configuration-conversion.ts](file://src/shared/proto-conversions/models/api-configuration-conversion.ts)
- [validate.ts](file://webview-ui/src/utils/validate.ts)
- [testBrowserConnection.ts](file://src/core/controller/browser/testBrowserConnection.ts)
- [TerminalManager.ts](file://src/integrations/terminal/TerminalManager.ts)
- [enhanced-terminal.js](file://standalone/runtime-files/vscode/enhanced-terminal.js)
- [refreshBasetenModels.ts](file://src/core/controller/models/refreshBasetenModels.ts) - *更新于提交 e9c8f678228a333a6cfc69e7bd0e06a5f25350f8*
- [baseten.ts](file://src/core/api/providers/baseten.ts) - *更新于提交 e9c8f678228a333a6cfc69e7bd0e06a5f25350f8*
- [execute_command.ts](file://src/core/prompts/system-prompt/tools/execute_command.ts) - *更新于提交 4e7af6eb5d7ce13236f82133efc224029c84a262*
- [tools.ts](file://src/shared/tools.ts) - *更新于提交 4e7af6eb5d7ce13236f82133efc224029c84a262*
- [tools.ts](file://src/core/prompts/system-prompt/components/tool_use/tools.ts) - *更新于提交 4e7af6eb5d7ce13236f82133efc224029c84a262*
</cite>

## 更新摘要
**已做更改**  
- 更新了“API提供商集成”部分，以反映Baseten模型现在支持动态获取。
- 在“VS Code深度集成”部分中增加了对多根工作区支持的说明。
- 添加了关于`execute_command`工具中多根工作区提示的详细信息。
- 更新了相关文件引用和来源注释以反映最新代码变更。

## 目录
1. [简介](#简介)
2. [MCP扩展机制](#mcp扩展机制)
3. [创建自定义MCP工具](#创建自定义mcp工具)
4. [API提供商集成](#api提供商集成)
5. [VS Code深度集成](#vs-code深度集成)
6. [浏览器集成](#浏览器集成)
7. [终端集成](#终端集成)
8. [结论](#结论)

## 简介
本文档详细介绍了如何将Cline与其他系统集成以及如何扩展其功能。重点阐述了MCP（Model Context Protocol）扩展机制，提供了从零开始创建自定义MCP工具的完整教程，包括定义工具规范、实现服务器端逻辑、在Cline中注册和使用该工具。同时，文档还说明了如何为新的LLM服务（如未被支持的开源模型）添加支持，包括创建新的API提供者类和处理认证。此外，还描述了与VS Code的深度集成点，如如何利用VS Code的API来实现文件操作、终端控制和UI更新，以及通过`src/services/browser/`与浏览器的交互和通过`src/integrations/terminal/`与终端的集成。

## MCP扩展机制
MCP（Model Context Protocol）是Cline的核心扩展机制，允许通过外部服务器提供工具和资源。MCP服务器可以提供多种工具和资源，这些工具和资源可以通过gRPC服务进行管理和调用。MCP服务定义了多个RPC方法，用于管理MCP服务器的生命周期和配置。

```mermaid
service McpService {
rpc toggleMcpServer(ToggleMcpServerRequest) returns (McpServers);
rpc updateMcpTimeout(UpdateMcpTimeoutRequest) returns (McpServers);
rpc addRemoteMcpServer(AddRemoteMcpServerRequest) returns (McpServers);
rpc downloadMcp(StringRequest) returns (McpDownloadResponse);
rpc restartMcpServer(StringRequest) returns (McpServers);
rpc deleteMcpServer(StringRequest) returns (McpServers);
rpc toggleToolAutoApprove(ToggleToolAutoApproveRequest) returns (McpServers);
rpc refreshMcpMarketplace(EmptyRequest) returns (McpMarketplaceCatalog);
rpc openMcpSettings(EmptyRequest) returns (Empty);
// Subscribe to MCP marketplace catalog updates
rpc subscribeToMcpMarketplaceCatalog(EmptyRequest) returns (stream McpMarketplaceCatalog);
rpc getLatestMcpServers(Empty) returns (McpServers);
// Subscribe to MCP server updates
rpc subscribeToMcpServers(EmptyRequest) returns (stream McpServers);
}
```

**Diagram sources**
- [mcp.proto](file://proto/cline/mcp.proto#L1-L42)

**Section sources**
- [mcp.proto](file://proto/cline/mcp.proto#L1-L42)

## 创建自定义MCP工具
创建自定义MCP工具涉及以下几个步骤：定义工具规范、实现服务器端逻辑、在Cline中注册和使用该工具。

### 定义工具规范
首先，需要定义MCP工具的规范。这包括工具的名称、描述、输入参数等。工具规范通过`McpTool`消息定义，包含以下字段：
- `name`: 工具的名称
- `description`: 工具的描述
- `input_schema`: 输入参数的JSON模式
- `auto_approve`: 是否自动批准该工具的使用

```mermaid
message McpTool {
string name = 1;
optional string description = 2;
optional string input_schema = 3;
optional bool auto_approve = 4;
}
```

**Diagram sources**
- [mcp.proto](file://proto/cline/mcp.proto#L44-L94)

**Section sources**
- [mcp.proto](file://proto/cline/mcp.proto#L44-L94)

### 实现服务器端逻辑
接下来，需要实现MCP服务器的逻辑。这通常涉及创建一个Node.js项目，并使用`@modelcontextprotocol/create-server`工具来生成项目结构。项目结构包括`index.ts`文件，其中定义了MCP服务器的主要逻辑。

```bash
cd ${await mcpHub.getMcpServersPath()}
npx @modelcontextprotocol/create-server weather-server
cd weather-server
# Install dependencies
npm install axios
```

**Section sources**
- [loadMcpDocumentation.ts](file://src/core/prompts/loadMcpDocumentation.ts#L11-L25)

### 在Cline中注册和使用该工具
最后，需要在Cline中注册和使用该工具。这可以通过调用`addRemoteMcpServer`方法来实现，该方法接受服务器名称和URL作为参数。

```typescript
export async function addRemoteMcpServer(controller: Controller, request: AddRemoteMcpServerRequest): Promise<McpServers> {
	try {
		// Validate required fields
		if (!request.serverName) {
			throw new Error("Server name is required")
		}
		if (!request.serverUrl) {
			throw new Error("Server URL is required")
		}

		// Call the McpHub method to add the remote server
		const servers = await controller.mcpHub?.addRemoteServer(request.serverName, request.serverUrl)

		const protoServers = convertMcpServersToProtoMcpServers(servers)

		return McpServers.create({ mcpServers: protoServers })
	} catch (error) {
		console.error(`Failed to add remote MCP server ${request.serverName}:`, error)

		throw error
	}
}
```

**Section sources**
- [addRemoteMcpServer.ts](file://src/core/controller/mcp/addRemoteMcpServer.ts#L0-L32)

## API提供商集成
为了支持新的LLM服务（如未被支持的开源模型），需要创建新的API提供者类并处理认证。API提供者类负责与特定的LLM服务进行通信，处理认证和请求。

### 创建新的API提供者类
新的API提供者类需要实现`ApiProvider`接口，并提供必要的认证信息。例如，对于一个新的提供商`myNewProvider`，需要在`api-configuration-conversion.ts`文件中添加相应的转换逻辑。

```typescript
function convertApiProviderToProto(provider: string | undefined): ProtoApiProvider {
	switch (provider) {
		case "myNewProvider":
			return ProtoApiProvider.MY_NEW_PROVIDER
		// other cases
	}
}
```

**Section sources**
- [api-configuration-conversion.ts](file://src/shared/proto-conversions/models/api-configuration-conversion.ts#L185-L232)

### 处理认证
认证信息通常通过环境变量或配置文件提供。在`validate.ts`文件中，需要添加验证逻辑以确保提供了有效的API密钥。

```typescript
case "myNewProvider":
	if (!apiConfiguration.myNewProviderApiKey) {
		return "You must provide a valid API key or choose a different provider."
	}
	break
```

**Section sources**
- [validate.ts](file://webview-ui/src/utils/validate.ts#L55-L98)

### Baseten模型动态获取
Baseten模型现在支持动态获取，通过API密钥从Baseten服务端获取最新的模型列表。如果未提供API密钥，则回退到静态模型列表。

```typescript
export async function refreshBasetenModels(
	controller: Controller,
	_request: EmptyRequest,
): Promise<OpenRouterCompatibleModelInfo> {
	console.log("=== refreshBasetenModels called ===")
	const basetenModelsFilePath = path.join(await ensureCacheDirectoryExists(), GlobalFileNames.basetenModels)

	// Get the Baseten API key from the controller's state
	const basetenApiKey = controller.stateManager.getSecretKey("basetenApiKey")

	const models: Record<string, Partial<OpenRouterModelInfo> & { supportedFeatures?: string[] }> = {}
	try {
		if (!basetenApiKey) {
			console.log("No Baseten API key found, using static models as fallback")
			// Don't throw an error, just use static models, althought this might be slightly out of date
			for (const [modelId, modelInfo] of Object.entries(basetenModels)) {
				models[modelId] = {
					maxTokens: modelInfo.maxTokens,
					contextWindow: modelInfo.contextWindow,
					supportsImages: modelInfo.supportsImages,
					supportsPromptCache: modelInfo.supportsPromptCache,
					inputPrice: modelInfo.inputPrice,
					outputPrice: modelInfo.outputPrice,
					cacheWritesPrice: (modelInfo as any).cacheWritesPrice || 0,
					cacheReadsPrice: (modelInfo as any).cacheReadsPrice || 0,
					description: (modelInfo as any).description || `${modelId} model`,
				}
			}
		} else {
			// Ensure the API key is properly formatted
			const cleanApiKey = basetenApiKey.trim()
			if (!cleanApiKey) {
				throw new Error("Invalid Baseten API key format")
			}

			console.log("Fetching Baseten models with API key:", cleanApiKey.substring(0, 10) + "...")

			const response = await axios.get("https://inference.baseten.co/v1/models", {
				headers: {
					Authorization: `Bearer ${cleanApiKey}`,
					"Content-Type": "application/json",
					"User-Agent": "Cline-VSCode-Extension",
				},
				timeout: 10000, // 10 second timeout
			})

			if (response.data?.data) {
				const rawModels = response.data.data

				for (const rawModel of rawModels) {
					// Filter out non-chat models and validate model capabilities
					if (!isValidChatModel(rawModel)) {
						continue
					}

					// Check if we have static pricing information for this model
					const staticModelInfo = basetenModels[rawModel.id as keyof typeof basetenModels]

					const modelInfo: Partial<OpenRouterModelInfo> & { supportedFeatures?: string[] } = {
						maxTokens: rawModel.max_completion_tokens || staticModelInfo?.maxTokens,
						contextWindow: rawModel.context_length || staticModelInfo?.contextWindow,
						supportsImages: false, // Baseten model APIs does not support image input
						supportsPromptCache: staticModelInfo?.supportsPromptCache || false,
						inputPrice: parsePrice(rawModel.pricing?.prompt) || staticModelInfo?.inputPrice || 0,
						outputPrice: parsePrice(rawModel.pricing?.completion) || staticModelInfo?.outputPrice || 0,
						cacheWritesPrice: staticModelInfo?.cacheWritesPrice || 0,
						cacheReadsPrice: staticModelInfo?.cacheReadsPrice || 0,
						description: generateModelDescription(rawModel, staticModelInfo),
						supportedFeatures: rawModel.supported_features || [],
					}

					models[rawModel.id] = modelInfo
				}
			} else {
				console.error("Invalid response from Baseten API")
			}
			await fs.writeFile(basetenModelsFilePath, JSON.stringify(models))
			console.log("Baseten models fetched and saved:", Object.keys(models))
		}
	} catch (error) {
		console.error("Error fetching Baseten models:", error)

		// Provide more specific error messages
		let errorMessage = "Unknown error occurred"
		if (axios.isAxiosError(error)) {
			if (error.response?.status === 401) {
				errorMessage = "Invalid Baseten API key. Please check your API key in settings."
			} else if (error.response?.status === 403) {
				errorMessage = "Access forbidden. Please verify your Baseten API key has the correct permissions."
			} else if (error.response?.status === 429) {
				errorMessage = "Rate limit exceeded. Please try again later."
			} else if (error.code === "ECONNABORTED") {
				errorMessage = "Request timeout. Please check your internet connection."
			} else {
				errorMessage = `API request failed: ${error.response?.status || error.code || "Unknown error"}`
			}
		} else if (error instanceof Error) {
			errorMessage = error.message
		}

		console.error("Baseten API Error:", errorMessage)

		// If we failed to fetch models, try to read cached models first
		const cachedModels = await readBasetenModels()
		if (cachedModels && Object.keys(cachedModels).length > 0) {
			console.log("Using cached Baseten models")
			// Use all cached models (no filtering)
			for (const [modelId, modelInfo] of Object.entries(cachedModels)) {
				models[modelId] = modelInfo
			}
		} else {
			// Fall back to static models from shared/api.ts
			console.log("Using static Baseten models as fallback")
			for (const [modelId, modelInfo] of Object.entries(basetenModels)) {
				models[modelId] = {
					maxTokens: modelInfo.maxTokens,
					contextWindow: modelInfo.contextWindow,
					supportsImages: modelInfo.supportsImages,
					supportsPromptCache: modelInfo.supportsPromptCache,
					inputPrice: modelInfo.inputPrice,
					outputPrice: modelInfo.outputPrice,
					cacheWritesPrice: (modelInfo as any).cacheWritesPrice || 0,
					cacheReadsPrice: (modelInfo as any).cacheReadsPrice || 0,
					description: (modelInfo as any).description || `${modelId} model`,
				}
			}
		}
	}

	// Convert the Record<string, Partial<OpenRouterModelInfo>> to Record<string, OpenRouterModelInfo>
	// by filling in any missing required fields with defaults
	const typedModels: Record<string, OpenRouterModelInfo> = {}
	for (const [key, model] of Object.entries(models)) {
		typedModels[key] = {
			maxTokens: model.maxTokens ?? 8192,
			contextWindow: model.contextWindow ?? 8192,
			supportsImages: model.supportsImages ?? false,
			supportsPromptCache: model.supportsPromptCache ?? false,
			inputPrice: model.inputPrice ?? 0,
			outputPrice: model.outputPrice ?? 0,
			cacheWritesPrice: model.cacheWritesPrice ?? 0,
			cacheReadsPrice: model.cacheReadsPrice ?? 0,
			description: model.description ?? "",
			tiers: model.tiers ?? [],
			// Note: supportedFeatures is preserved as custom property but not part of OpenRouterModelInfo proto
		}
	}

	return OpenRouterCompatibleModelInfo.create({ models: typedModels })
}
```

**Section sources**
- [refreshBasetenModels.ts](file://src/core/controller/models/refreshBasetenModels.ts#L17-L166)
- [baseten.ts](file://src/core/api/providers/baseten.ts#L0-L160)

## VS Code深度集成
Cline通过VS Code的API实现了深度集成，包括文件操作、终端控制和UI更新。

### 文件操作
Cline利用VS Code的API来实现文件操作，如打开文件、读取文件内容等。这些操作通过`VscodeWebviewProvider`类实现。

### 终端控制
Cline通过`TerminalManager`类实现终端控制，包括运行命令、获取终端输出等。`TerminalManager`类提供了`runCommand`方法来执行终端命令。

```typescript
runCommand(terminalInfo: TerminalInfo, command: string): TerminalProcessResultPromise {
	console.log(`[TerminalManager] Running command on terminal ${terminalInfo.id}: "${command}"`)
	console.log(`[TerminalManager] Terminal ${terminalInfo.id} busy state before: ${terminalInfo.busy}`)

	terminalInfo.busy = true
	terminalInfo.lastCommand = command
	const process = new TerminalProcess()
	this.processes.set(terminalInfo.id, process)

	process.once("completed", () => {
		console.log(`[TerminalManager] Terminal ${terminalInfo.id} completed, setting busy to false`)
		terminalInfo.busy = false
	})

	// if shell integration is not available, remove terminal so it does not get reused as it may be running a long-running process
	process.once("no_shell_integration", () => {
		console.log(`no_shell_integration received for terminal ${terminalInfo.id}`)
		// Remove the terminal so we can't reuse it (in case it's running a long-running process)
		TerminalRegistry.removeTerminal(terminalInfo.id)
		this.terminalIds.delete(terminalInfo.id)
		this.processes.delete(terminalInfo.id)
	})

	const promise = new Promise<void>((resolve, reject) => {
		process.once("continue", () => {
			resolve()
		})
		process.once("error", (error) => {
			console.error(`Error in terminal ${terminalInfo.id}:`, error)
			reject(error)
		})
	})
}
```

**Section sources**
- [TerminalManager.ts](file://src/integrations/terminal/TerminalManager.ts#L150-L188)

### 多根工作区支持
Cline现在支持多根工作区，允许在多个工作区之间执行命令。`execute_command`工具现在包含多根工作区提示。

```typescript
const generic: ClineToolSpec = {
	variant: ModelFamily.GENERIC,
	id: ClineDefaultTool.BASH,
	name: "execute_command",
	description: `Request to execute a CLI command on the system. Use this when you need to perform system operations or run specific commands to accomplish any step in the user's task. You must tailor your command to the user's system and provide a clear explanation of what the command does. For command chaining, use the appropriate chaining syntax for the user's shell. Prefer to execute complex CLI commands over creating executable scripts, as they are more flexible and easier to run. Commands will be executed in the current working directory: {{CWD}}{{MULTI_ROOT_HINT}}`,
	parameters: [
		{
			name: "command",
			required: true,
			instruction: `The CLI command to execute. This should be valid for the current operating system. Ensure the command is properly formatted and does not contain any harmful instructions.`,
			usage: "Your command here",
		},
		{
			name: "requires_approval",
			required: true,
			instruction:
				"A boolean indicating whether this command requires explicit user approval before execution in case the user has auto-approve mode enabled. Set to 'true' for potentially impactful operations like installing/uninstalling packages, deleting/overwriting files, system configuration changes, network operations, or any commands that could have unintended side effects. Set to 'false' for safe operations like reading files/directories, running development servers, building projects, and other non-destructive operations.",
			usage: "true or false",
		},
		{
			name: "timeout",
			required: false,
			contextRequirements: (context) => context.yoloModeToggled === true,
			instruction:
				"Integer representing the timeout in seconds for how long to run the terminal command, before timing out and continuing the task.",
			usage: "30",
		},
	],
}
```

**Section sources**
- [execute_command.ts](file://src/core/prompts/system-prompt/tools/execute_command.ts#L0-L66)
- [tools.ts](file://src/core/prompts/system-prompt/components/tool_use/tools.ts#L0-L42)
- [tools.ts](file://src/shared/tools.ts#L0-L28)

### UI更新
Cline通过`WebviewProvider`类实现UI更新，包括显示通知、更新状态栏等。这些操作通过`VscodeWebviewProvider`类实现。

## 浏览器集成
Cline通过`BrowserSession`类实现与浏览器的集成，包括测试浏览器连接、获取浏览器连接信息等。

### 测试浏览器连接
`testBrowserConnection`方法用于测试与浏览器实例的连接。

```typescript
export async function testBrowserConnection(controller: Controller, request: StringRequest): Promise<BrowserConnection> {
	try {
		const browserSettings = controller.stateManager.getGlobalStateKey("browserSettings")
		const browserSession = new BrowserSession(controller.context, browserSettings)
		const text = request.value || ""
		// Implementation details
	}
}
```

**Section sources**
- [testBrowserConnection.ts](file://src/core/controller/browser/testBrowserConnection.ts#L0-L16)

### 获取浏览器连接信息
`getBrowserConnectionInfo`方法用于获取当前浏览器连接的信息。

```typescript
export async function getBrowserConnectionInfo(controller: Controller, _: EmptyRequest): Promise<BrowserConnectionInfo> {
	try {
		// Get browser settings from extension state
		const browserSettings = controller.stateManager.getGlobalStateKey("browserSettings")

		// Check if there's an active browser session by using the controller's handleWebviewMessage approach
		// This is similar to what's done in controller/index.ts for the "getBrowserConnectionInfo" message
		if (controller.task?.browserSession) {
			// Access the browser session through the controller's task property
			// Using indexer notation to access private property
			const browserSession = controller.task.browserSession
			const connectionInfo = browserSession.getConnectionInfo()

			// Convert from BrowserSession.BrowserConnectionInfo to proto.BrowserConnectionInfo
			return BrowserConnectionInfo.create({
				isConnected: connectionInfo.isConnected,
				isRemote: connectionInfo.isRemote,
				host: connectionInfo.host || "", // Ensure host is never undefined
			})
		}
	}
}
```

**Section sources**
- [getBrowserConnectionInfo.ts](file://src/core/controller/browser/getBrowserConnectionInfo.ts#L0-L29)

## 终端集成
Cline通过`TerminalManager`类实现与终端的集成，包括运行命令、关闭终端等。

### 运行命令
`runCommand`方法用于在终端中运行命令。

```typescript
runCommand(terminalInfo: TerminalInfo, command: string): TerminalProcessResultPromise {
	console.log(`[TerminalManager] Running command on terminal ${terminalInfo.id}: "${command}"`)
	console.log(`[TerminalManager] Terminal ${terminalInfo.id} busy state before: ${terminalInfo.busy}`)

	terminalInfo.busy = true
	terminalInfo.lastCommand = command
	const process = new TerminalProcess()
	this.processes.set(terminalInfo.id, process)

	process.once("completed", () => {
		console.log(`[TerminalManager] Terminal ${terminalInfo.id} completed, setting busy to false`)
		terminalInfo.busy = false
	})

	// if shell integration is not available, remove terminal so it does not get reused as it may be running a long-running process
	process.once("no_shell_integration", () => {
		console.log(`no_shell_integration received for terminal ${terminalInfo.id}`)
		// Remove the terminal so we can't reuse it (in case it's running a long-running process)
		TerminalRegistry.removeTerminal(terminalInfo.id)
		this.terminalIds.delete(terminalInfo.id)
		this.processes.delete(terminalInfo.id)
	})

	const promise = new Promise<void>((resolve, reject) => {
		process.once("continue", () => {
			resolve()
		})
		process.once("error", (error) => {
			console.error(`Error in terminal ${terminalInfo.id}:`, error)
			reject(error)
		})
	})
}
```

**Section sources**
- [TerminalManager.ts](file://src/integrations/terminal/TerminalManager.ts#L150-L188)

### 关闭终端
`closeTerminals`方法用于关闭匹配指定条件的终端。

```typescript
closeTerminals(filterFn: (terminal: TerminalInfo) => boolean, force: boolean = false): number {
	const terminalsToClose = this.filterTerminals(filterFn)
	let closedCount = 0

	for (const terminalInfo of terminalsToClose) {
		// Skip busy terminals unless force is true
		if (terminalInfo.busy && !force) {
			continue
		}

		// Remove from our tracking
		if (this.terminalIds.has(terminalInfo.id)) {
			this.terminalIds.delete(terminalInfo.id)
		}
		this.processes.delete(terminalInfo.id)

		// Dispose the actual terminal
		terminalInfo.terminal.dispose()

		// Remove from registry
		TerminalRegistry.removeTerminal(terminalInfo.id)

		closedCount++
	}

	return closedCount
}
```

**Section sources**
- [TerminalManager.ts](file://src/integrations/terminal/TerminalManager.ts#L385-L430)

## 结论
本文档详细介绍了如何将Cline与其他系统集成以及如何扩展其功能。通过MCP扩展机制，可以轻松创建自定义工具和资源。通过创建新的API提供者类和处理认证，可以支持新的LLM服务。通过VS Code的API，可以实现文件操作、终端控制和UI更新。通过`src/services/browser/`和`src/integrations/terminal/`，可以实现与浏览器和终端的集成。这些功能使得Cline成为一个强大且灵活的开发工具。